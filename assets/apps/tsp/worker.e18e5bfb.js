var K=Object.defineProperty;var Q=(g,a,w)=>a in g?K(g,a,{enumerable:!0,configurable:!0,writable:!0,value:w}):g[a]=w;var p=(g,a,w)=>(Q(g,typeof a!="symbol"?a+"":a,w),w);(function(){"use strict";const g=(i,t)=>Math.sqrt((i.x-t.x)**2+(i.y-t.y)**2);let a=[];const w=(i,t)=>{const e=i.map(()=>[...Array(i.length)]);return i.forEach(s=>i.forEach(n=>{e[s.id][n.id]=t(s,n)})),e};class h{constructor(t){p(this,"cities");p(this,"distance");if(this.cities=t,t.length<2)throw new Error("Trips must be at least 2 cities long");this.distance=this.calculateDistance()}calculateDistance(t=g){a.length===0&&(a=w(this.cities,t));const e=a[this.cities[0].id][this.cities[this.cities.length-1].id];return this.cities.slice(0,-1).reduce((s,n,r)=>a[n.id][this.cities[r+1].id]+s,e)}objectiveFunction(){return this.distance}}class A{constructor(t,e,s){p(this,"id");p(this,"x");p(this,"y");this.id=t,this.x=e,this.y=s}}const S=[[6734,1453],[2233,10],[5530,1424],[401,841],[3082,1644],[7608,4458],[7573,3716],[7265,1268],[6898,1885],[1112,2049],[5468,2606],[5989,2873],[4706,2674],[4612,2035],[6347,2683],[6107,669],[7611,5184],[7462,3590],[7732,4723],[5900,3561],[4483,3369],[6101,1110],[5199,2182],[1633,2809],[4307,2322],[675,1006],[7555,4819],[7541,3981],[3177,756],[7352,4506],[7545,2801],[3245,3305],[6426,3173],[4608,1198],[23,2216],[7248,3779],[7762,4595],[7392,2244],[3484,2829],[6271,2135],[4985,140],[1916,1569],[7280,4899],[7509,3239],[10,2676],[6807,2993],[5185,3258],[3023,1942]].map(([i,t],e)=>new A(e,i,t)),y=i=>{const t=[...i];let e=i.length,s=0;for(;e!=0;)s=Math.floor(Math.random()*e),e--,[t[e],t[s]]=[t[s],t[e]];return t};class l{constructor(t,e){p(this,"cities");p(this,"trip");this.cities=t,this.trip=e}static default(t){return new l(t,new h(t))}copy(){const t=new h([...this.trip.cities]);return new l(this.cities,t)}withNewPath(t){const e=new h(t);return new l(this.cities,e)}getPath(){return[...this.trip.cities]}cost(){return this.trip.objectiveFunction()}swap(t,e){const s=[...this.trip.cities];[s[e],s[t]]=[s[t],s[e]];const n=new h(s);return new l(this.cities,n)}twoOptSwap(t,e){const s=[...this.trip.cities.slice(0,t),...this.trip.cities.slice(t,e).reverse(),...this.trip.cities.slice(e)],n=new h(s);return new l(this.cities,n)}moveSubRoute(t,e,s){let n=[...this.trip.cities];n.splice(e,0,...n.splice(t,s));const r=new h(n);return new l(this.cities,r)}}const C={apply:i=>{const t=new h(y(i.cities));return new l(i.cities,t)}},d=(i,t=Math.random)=>Math.floor(t()*i),I={apply(i){const t=d(i.cities.length),e=d(i.cities.length);return i.moveSubRoute(t,e,1)}},O={apply(i){const t=d(i.cities.length);let e=i.copy();for(let s=0;s<i.cities.length;s++){const n=i.moveSubRoute(t,s,1);n.cost()<e.cost()&&(e=n)}return e}},F={apply(i){const t=d(i.cities.length),e=d(i.cities.length);return i.swap(t,e)}},G=(i,t,e)=>[...i.slice(0,t),...i.slice(t,e).reverse(),...i.slice(e)],M=[I,F,O,{apply(i){const t=i.getPath();for(let e=0;e<i.cities.length-1;e++)for(let s=e+1;s<i.cities.length;s++){const n=G(t,e,s),r=i.withNewPath(n);if(r.cost()<i.cost())return r}return i}}],B=()=>M[d(M.length)],$={apply:i=>B().apply(i)};class j{run(t=S,e,s,n=()=>{}){const r=l.default(t);let c=s||e.construction.apply(r),m=0,u=c;for(;!e.stoppingCriterion.shouldStop();){const U=e.move.apply(u);U.cost()<u.cost()&&(m=0,u=U,u.cost()<c.cost()&&(c=u),n(u)),m++>=e.staleMoveLimit&&(u=this.destroySolutionSegment(u))}return c}destroySolutionSegment(t){const e=t.getPath(),s=d(Math.round(e.length/2)),n=s+d(Math.round(e.length/2));return t.withNewPath([...e.slice(0,s),...y(e.slice(s,n)),...e.slice(n)])}}class H{constructor(){p(this,"numIterations",0);p(this,"totalTime",0);p(this,"startTime");this.startTime=new Date().getTime()}store(){this.numIterations++,this.totalTime+=new Date().getTime()-this.startTime}print(){console.log(`Total time taken ${(this.totalTime/this.numIterations).toFixed(2)}ms`)}}class b{run(t=S,e,s,n=()=>{}){const r=l.default(t);let c=s||e.construction.apply(r);const m=new H;for(;!e.stoppingCriterion.shouldStop();){const u=e.move.apply(c);u.cost()<c.cost()&&(c=u,n(c)),m.store()}return m.print(),c}}const V=i=>{let t=0;return{shouldStop:()=>i===t++,percentageProgress:()=>t/i}},N=(i,t=()=>new Date)=>{const e=t();e.setSeconds(e.getSeconds()+i);const s=t().getTime();return{shouldStop:()=>t()>=e,percentageProgress:()=>(t().getTime()-s)/(e.getTime()-s)}},E={random:C},W={hillClimbing:b,neighbourHood:j},L={random:C,randomMover:$,moveCity:I,moveCityToBest:O},P=1e3/60;let T,v="IDLE",f;const R=()=>{f=setTimeout(z,P)},k=()=>{R(),v="RUNNING"},q=()=>{!f||(clearTimeout(f),f=void 0)},x=()=>{q(),v="IDLE"};let o={cities:S,singleLoop:!1,construction:E.random,stoppingCriterion:()=>N(P*.9),mover:L.randomMover,debug:!1,runner:b},D=0;const _=10,z=()=>{if(v==="IDLE")return;const i=new o.runner().run(o.cities,{construction:o.construction,stoppingCriterion:o.stoppingCriterion(),move:o.mover},T,t=>{T=t,postMessage({type:"SOLUTION",solution:t}),D=0});if(o.singleLoop||D++>_){postMessage({type:"STOPPING",solution:i}),x();return}R()},J=i=>{switch(o.debug&&console.log(`received message ${i.data.type}`),i.data.type){case"SET_SOLUTION":{i.data.solution?T=new l(i.data.solution.cities,new h(i.data.solution.trip.cities)):T=void 0;return}case"START":{k();return}case"STOP":{x();return}case"CONFIGURE":{const{data:{construction:t,move:e,numIterations:s,timeout:n,singleLoop:r,debug:c,runner:m}}=i;t&&(o.construction=E[t]),e&&(o.mover=L[e]),s&&(o.stoppingCriterion=()=>V(s)),n&&(o.stoppingCriterion=()=>N(n)),r!==void 0&&(o.singleLoop=r),c!==void 0&&(o.debug=c),m!==void 0&&(o.runner=W[m]);return}default:console.error(i)}};addEventListener("message",J)})();
